---
title: Installation
description: Learn how to install Yuki Auth in your project, including database setup and package installation.
---

Follow these steps to install Yuki Auth in your project. The installation process may vary slightly depending on your framework and database choice.

## Getting Started

To begin, you'll need to create your database schema to store authentication data.

<Tabs items={['Drizzle', 'Prisma']}>

<Tab value="Drizzle">

<Steps>

<Step>
Create a new table in your database.

```ts title="server/db/schema.ts"
import { relations } from 'drizzle-orm'
import { pgTable, primaryKey } from 'drizzle-orm/pg-core'

export const users = pgTable('user', (t) => ({
  id: t.uuid().primaryKey().defaultRandom().notNull(),
  name: t.varchar({ length: 255 }).notNull(),
  email: t.varchar({ length: 255 }).unique().notNull(),
  image: t.varchar({ length: 255 }).notNull(),
  createdAt: t.timestamp().defaultNow().notNull(),
  updatedAt: t
    .timestamp({ mode: 'date', withTimezone: true })
    .defaultNow()
    .$onUpdateFn(() => new Date())
    .notNull(),
}))

export const usersRelations = relations(users, ({ many }) => ({
  accounts: many(accounts),
  sessions: many(sessions),
}))

export const accounts = pgTable(
  'account',
  (t) => ({
    provider: t.varchar({ length: 255 }).notNull(),
    accountId: t.varchar({ length: 255 }).notNull(),
    userId: t
      .uuid()
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    password: t.varchar({ length: 255 }),
  }),
  (account) => [primaryKey({ columns: [account.provider, account.accountId] })],
)

export const accountsRelations = relations(accounts, ({ one }) => ({
  user: one(users, { fields: [accounts.userId], references: [users.id] }),
}))

export const sessions = pgTable('session', (t) => ({
  token: t.varchar({ length: 255 }).primaryKey().notNull(),
  expires: t.timestamp({ mode: 'date', withTimezone: true }).notNull(),
  userId: t
    .uuid()
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
}))

export const sessionRelations = relations(sessions, ({ one }) => ({
  user: one(users, { fields: [sessions.userId], references: [users.id] }),
}))
```

</Step>

<Step>
Export your database instance.

```ts title="server/db/index.ts"
import { drizzle } from 'drizzle-orm/node-postgres'

import * as schema from './schema'

const createDrizzleClient = () =>
  drizzle(process.env.DATABASE_URL, {
    schema,
    casing: 'snake_case',
  })
const globalForDrizzle = globalThis as unknown as {
  db: ReturnType<typeof createDrizzleClient> | undefined
}
export const db = globalForDrizzle.db ?? createDrizzleClient()
if (process.env.NODE_ENV !== 'production') globalForDrizzle.db = db
```

</Step>

</Steps>

</Tab>

<Tab value="Prisma">

<Steps>

<Step>
Create a new table in your database.

```prisma title="prisma/schema.prisma"
generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"

  moduleFormat        = "esm"
  importFileExtension = ""
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String   @db.VarChar(255)
  email     String   @unique(map: "user_email_unique") @db.VarChar(255)
  image     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  accounts Account[]
  sessions Session[]

  @@map("user")
}

model Account {
  provider  String  @db.VarChar(255)
  accountId String  @map("account_id") @db.VarChar(255)
  password  String? @db.VarChar(255)

  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "account_user_id_user_id_fk")

  @@id([provider, accountId], map: "account_provider_account_id_pk")
  @@map("account")
}

model Session {
  token   String   @id @db.VarChar(255)
  expires DateTime @db.Timestamptz(6)

  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "session_user_id_user_id_fk")

  @@map("session")
}
```

</Step>

<Step>
Export your database instance.

```ts title="server/db.ts"
import { PrismaClient } from '@/generated/prisma'

const createPrismaClient = () => new PrismaClient()
const globalForPrisma = globalThis as unknown as {
  db: ReturnType<typeof createPrismaClient> | undefined
}
export const db = globalForPrisma.db ?? createPrismaClient()
if (process.env.NODE_ENV !== 'production') globalForPrisma.db = db
```

</Step>

</Steps>

</Tab>

</Tabs>

## Install the Yuki Auth package.

### Use the CLI

First, install the database adapter for your database.

<InstallComponent name="auth-with-{database}" />

> Replace `{database}` with your database choice (e.g., `auth-with-drizzle`, `auth-with-prisma`).

Then, Install the Yuki Auth package.

<InstallComponent name="auth" />

<Callout>

By default, Yuki Auth uses sha3_512 from @oslojs/crypto for password hashing. You can also use other algorithms like:

- bcrypt
- Argon2
- scrypt

For enhanced security, consider using Argon2 or scrypt as they're designed specifically for password hashing with stronger resistance against brute-force attacks.

</Callout>

3. Install OAuth providers.

These OAuth providers are implemented using [Arctic](https://arcticjs.dev/), a collection of OAuth 2.0 clients for popular providers.

<InstallComponent name="auth-{provider}" />

Replace `{provider}` with the OAuth provider you want to use. Currently supported providers:

- google
- discord
- github
- facebook

Example:

<InstallComponent name="auth-google" />

<Callout>
Remember to add environment variables for your OAuth providers. You can find the required environment variables in the documentation for each provider.

```bash
{PROVIDER}_CLIENT_ID=your-client-id
{PROVIDER}_CLIENT_SECRET=your-client-secret
```

Example for Google:

```bash
GOOGLE_CLIENT_ID=your-client-id
GOOGLE_CLIENT_SECRET=your-client-secret
```

</Callout>

Final, add OAuth providers to your Auth configuration.

```ts title="server/auth/config.ts"
import type { AuthOptions } from '@/server/auth/types'
import { GoogleProvider } from '@/server/auth/providers/google'

export const authOptions = {
  google: new GoogleProvider(),
} satisfies AuthOptions
```

### Manual Installation

You can find all the necessary code in our GitHub repository: [https://github.com/tiesen243/yuki-ui/tree/main/registry/auth](https://github.com/tiesen243/yuki-ui/tree/main/registry/auth).

## Notes

If you're implementing Yuki Auth in a framework other than Next.js, remember to remove any imports of `cookies` from `next/headers` and replace them with the appropriate cookie management solution for your framework.

Example:

<Tabs items={['Next.js', 'Other frameworks']}>
<Tab value="Next.js">

```ts title="server/auth/core/cookies.ts"
async function getCookie(
  key: string,
  req?: Request,
): Promise<string | undefined> {
  if (req) {
    const cookies = req.headers
      .get('cookie')
      ?.split(';')
      .reduce((acc: Record<string, string>, cookie) => {
        const [key, value] = cookie.trim().split('=')
        if (key && value) acc[key] = decodeURIComponent(value)
        return acc
      }, {})
    return cookies?.[key]
  }
  return (await cookies()).get(key)?.value
}
```

</Tab>

<Tab value="Other frameworks">

```ts title="server/auth/core/cookies.ts"
async function getCookie(
  key: string,
  req: Request, // make sure the `req` parameter is required
): Promise<string | undefined> {
  const cookies = req.headers
    .get('cookie')
    ?.split(';')
    .reduce((acc: Record<string, string>, cookie) => {
      const [key, value] = cookie.trim().split('=')
      if (key && value) acc[key] = decodeURIComponent(value)
      return acc
    }, {})
  return cookies?.[key]
}
```

</Tab>

</Tabs>
