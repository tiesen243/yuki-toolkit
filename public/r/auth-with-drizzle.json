{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "auth-with-drizzle",
  "type": "registry:file",
  "files": [
    {
      "path": "registry/auth/core/queries.drizzle.ts.hbs",
      "content": "'use server'\n\nimport { sha256 } from '@oslojs/crypto/sha2'\nimport {\n  encodeBase32LowerCaseNoPadding,\n  encodeHexLowerCase,\n} from '@oslojs/encoding'\nimport { and, eq } from 'drizzle-orm'\n\nimport type { SessionResult } from '@/server/auth/types'\nimport { authOptions } from '@/server/auth/config'\nimport { Password } from '@/server/auth/core/password'\nimport { db } from '@/server/db'\nimport { accounts, sessions, users } from '@/server/db/schema'\n\nasync function createSession(\n  userId: string,\n): Promise<{ sessionToken: string; expires: Date }> {\n  const bytes = new Uint8Array(20)\n  crypto.getRandomValues(bytes)\n  const sessionToken = encodeBase32LowerCaseNoPadding(bytes)\n\n  const token = hashSHA256(sessionToken)\n  const expires = new Date(Date.now() + authOptions.session.expires)\n\n  // Store the hashed token in the database\n  const [session] = await db\n    .insert(sessions)\n    .values({ token, expires, userId })\n    .returning()\n  if (!session) throw new Error('Failed to create session')\n\n  // Return the unhashed token to the client along with expiration\n  return { sessionToken, expires: session.expires }\n}\n\nasync function validateToken(token: string): Promise<SessionResult> {\n  const sessionToken = hashSHA256(token)\n\n  // Lookup the session and associated user in the database\n  const result = await db.query.sessions.findFirst({\n    where: (sessions, { eq }) => eq(sessions.token, sessionToken),\n    with: { user: true },\n  })\n\n  // Return early if session not found\n  if (!result) return { expires: new Date() }\n\n  const { user, ...session } = result\n  const now = Date.now()\n\n  // Check if session has expired\n  if (now > session.expires.getTime()) {\n    await db.delete(sessions).where(eq(sessions.token, sessionToken))\n    return { expires: new Date() }\n  }\n\n  // Refresh session if it's beyond the refresh threshold\n  if (now >= session.expires.getTime() - authOptions.session.expiresThreshold) {\n    const newExpires = new Date(Date.now() + authOptions.session.expires)\n    await db\n      .update(sessions)\n      .set({ expires: newExpires })\n      .where(eq(sessions.token, sessionToken))\n    session.expires = newExpires\n  }\n\n  return { user, expires: session.expires }\n}\n\nasync function invalidateToken(token: string): Promise<void> {\n  await db.delete(sessions).where(eq(sessions.token, hashSHA256(token)))\n}\n\nasync function invalidateAllTokens(userId: string): Promise<void> {\n  await db.delete(sessions).where(eq(sessions.userId, userId))\n}\n\nasync function verifyCredentials(input: {\n  email: string\n  password: string\n}): Promise<{ sessionToken: string; expires: Date }> {\n  const [user] = await db\n    .select({ id: users.id, password: accounts.password })\n    .from(users)\n    .where(eq(users.email, input.email))\n    .innerJoin(\n      accounts,\n      and(eq(accounts.provider, 'credentials'), eq(accounts.userId, users.id)),\n    )\n\n  if (\n    !user?.password ||\n    !(await new Password().verify(user.password, input.password))\n  )\n    throw new Error('Invalid email or password')\n\n  return createSession(user.id)\n}\n\nasync function getOrCreateUserFromOAuth(data: {\n  provider: string\n  accountId: string\n  name: string\n  email: string\n  image: string\n}): Promise<typeof users.$inferSelect> {\n  const { provider, accountId, email } = data\n\n  const existingAccount = await db.query.accounts.findFirst({\n    where: (accounts, { and, eq }) =>\n      and(eq(accounts.provider, provider), eq(accounts.accountId, accountId)),\n    with: { user: true },\n  })\n  if (existingAccount?.user) return existingAccount.user\n\n  return await db.transaction(async (tx) => {\n    const existingUser = await tx.query.users.findFirst({\n      where: (user, { eq }) => eq(user.email, email),\n    })\n\n    if (existingUser) {\n      await tx.insert(accounts).values({\n        provider,\n        accountId,\n        userId: existingUser.id,\n      })\n      return existingUser\n    }\n\n    const [newUser] = await tx.insert(users).values(data).returning()\n    if (!newUser) throw new Error('Failed to create user')\n\n    await tx.insert(accounts).values({\n      provider,\n      accountId,\n      userId: newUser.id,\n    })\n\n    return newUser\n  })\n}\n\nfunction hashSHA256(str: string): string {\n  return encodeHexLowerCase(sha256(new TextEncoder().encode(str)))\n}\n\nexport {\n  // Authentication\n  verifyCredentials,\n  getOrCreateUserFromOAuth,\n  // Session management\n  createSession,\n  validateToken,\n  invalidateToken,\n  invalidateAllTokens,\n}\n",
      "type": "registry:file",
      "target": "server/auth/core/queries.ts"
    },
    {
      "path": "registry/auth/types.drizzle.ts.hbs",
      "content": "import type { authOptions } from '@/server/auth/config'\nimport type { BaseProvider } from '@/server/auth/providers/base'\nimport type { users } from '@/server/db/schema'\n\nexport type Providers = Record<string, BaseProvider>\n\nexport interface AuthOptions<T extends Providers = Providers> {\n  cookieKey: string\n  cookieOptions: {\n    expires?: Date | number\n    maxAge?: number\n    domain?: string\n    path: string\n    secure: boolean\n    httpOnly: boolean\n    sameSite: 'strict' | 'lax' | 'none'\n    priority?: 'low' | 'medium' | 'high'\n    [key: string]: unknown\n  }\n  session: {\n    expires: number\n    expiresThreshold: number\n  }\n  providers: T\n}\n\nexport interface SessionResult {\n  user?: typeof users.$inferSelect\n  expires: Date\n}\n\nexport type Options = typeof authOptions\n",
      "type": "registry:file",
      "target": "server/auth/types.ts"
    }
  ]
}