{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "auth-with-memory",
  "type": "registry:file",
  "files": [
    {
      "path": "registry/auth/core/queries.memory.ts.hbs",
      "content": "'use server'\n\nimport { sha256 } from '@oslojs/crypto/sha2'\nimport {\n  encodeBase32LowerCaseNoPadding,\n  encodeHexLowerCase,\n} from '@oslojs/encoding'\n\nimport type { SessionResult } from '@/server/auth/types'\nimport type { User } from '@/server/db/schema'\nimport { authOptions } from '@/server/auth/config'\nimport { Password } from '@/server/auth/core/password'\nimport { db } from '@/server/db'\n\nasync function createSession(\n  userId: string,\n): Promise<{ sessionToken: string; expires: Date }> {\n  await new Promise((resolve) => setTimeout(resolve, 500))\n\n  const bytes = new Uint8Array(20)\n  crypto.getRandomValues(bytes)\n  const sessionToken = encodeBase32LowerCaseNoPadding(bytes)\n\n  const token = hashSHA256(sessionToken)\n  const expires = new Date(Date.now() + authOptions.session.expires)\n\n  // Store the hashed token in the database\n  db.sessions.push({ token, expires, userId })\n  const session = db.sessions.find((s) => s.token === token)\n  if (!session) throw new Error('Failed to create session')\n\n  // Return the unhashed token to the client along with expiration\n  return { sessionToken, expires }\n}\n\nasync function validateToken(token: string): Promise<SessionResult> {\n  await new Promise((resolve) => setTimeout(resolve, 500))\n\n  const sessionToken = hashSHA256(token)\n\n  // Lookup the session and associated user in the database\n  const result = db.sessions.find((s) => s.token === sessionToken)\n\n  // Return early if session not found\n  if (!result) return { expires: new Date() }\n  else result.user = db.users.find((u) => u.id === result.userId)\n\n  const { user, ...session } = result\n  const now = Date.now()\n\n  // Check if session has expired\n  if (now > session.expires.getTime()) {\n    db.sessions.splice(\n      db.sessions.findIndex((s) => s.token === sessionToken),\n      1,\n    )\n    return { expires: new Date() }\n  }\n\n  // Refresh session if it's beyond the refresh threshold\n  if (now >= session.expires.getTime() - authOptions.session.expiresThreshold) {\n    const newExpires = new Date(Date.now() + authOptions.session.expires)\n    const sessionIndex = db.sessions.findIndex((s) => s.token === sessionToken)\n    if (db.sessions[sessionIndex])\n      db.sessions[sessionIndex].expires = newExpires\n    session.expires = newExpires\n  }\n\n  return { user, expires: session.expires }\n}\n\nasync function invalidateToken(token: string): Promise<void> {\n  await new Promise((resolve) => setTimeout(resolve, 500))\n  const sessionIndex = db.sessions.findIndex(\n    (s) => s.token === hashSHA256(token),\n  )\n  if (sessionIndex !== -1) db.sessions.splice(sessionIndex, 1)\n}\n\nasync function invalidateAllTokens(userId: string): Promise<void> {\n  await new Promise((resolve) => setTimeout(resolve, 500))\n  db.sessions = db.sessions.filter((s) => s.userId !== userId)\n}\n\nasync function verifyCredentials(input: {\n  email: string\n  password: string\n}): Promise<{ sessionToken: string; expires: Date }> {\n  await new Promise((resolve) => setTimeout(resolve, 500))\n\n  const user = db.users.find((u) => u.email === input.email)\n  const account = db.accounts.find(\n    (a) =>\n      a.provider === 'credentials' &&\n      a.userId === user?.id &&\n      a.password === input.password,\n  )\n\n  if (\n    !user ||\n    !account?.password ||\n    !(await new Password().verify(account.password, input.password))\n  )\n    throw new Error('Invalid email or password')\n\n  return createSession(user.id)\n}\n\nasync function getOrCreateUserFromOAuth(data: {\n  provider: string\n  accountId: string\n  name: string\n  email: string\n  image: string\n}): Promise<User> {\n  await new Promise((resolve) => setTimeout(resolve, 500))\n\n  const { provider, accountId, email } = data\n\n  const existingAccount = db.accounts.find(\n    (a) => a.provider === provider && a.accountId === accountId,\n  )\n  const existingUser = db.users.find((u) => u.email === email)\n  if (existingUser && existingAccount) return existingUser\n  else if (existingUser && !existingAccount) {\n    db.accounts.push({\n      provider,\n      accountId,\n      userId: existingUser.id,\n    })\n    return existingUser\n  } else {\n    db.users.push({\n      id: crypto.randomUUID(),\n      name: data.name,\n      email: data.email,\n      image: data.image,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    })\n    const newUser = db.users[db.users.length - 1]\n    if (!newUser) throw new Error('Failed to create user')\n\n    db.accounts.push({\n      provider,\n      accountId,\n      userId: newUser.id,\n    })\n\n    return newUser\n  }\n}\n\nfunction hashSHA256(str: string): string {\n  return encodeHexLowerCase(sha256(new TextEncoder().encode(str)))\n}\n\nexport {\n  // Authentication\n  verifyCredentials,\n  getOrCreateUserFromOAuth,\n  // Session management\n  createSession,\n  validateToken,\n  invalidateToken,\n  invalidateAllTokens,\n}\n",
      "type": "registry:file",
      "target": "server/auth/core/queries.ts"
    },
    {
      "path": "registry/auth/types.memory.ts.hbs",
      "content": "import type { authOptions } from '@/server/auth/config'\nimport type { BaseProvider } from '@/server/auth/providers/base'\nimport type { User } from '@/server/db/schema'\n\nexport type Providers = Record<string, BaseProvider>\n\nexport interface AuthOptions<T extends Providers = Providers> {\n  cookieKey: string\n  cookieOptions: {\n    expires?: Date | number\n    maxAge?: number\n    domain?: string\n    path: string\n    secure: boolean\n    httpOnly: boolean\n    sameSite: 'strict' | 'lax' | 'none'\n    priority?: 'low' | 'medium' | 'high'\n    [key: string]: unknown\n  }\n  session: {\n    expires: number\n    expiresThreshold: number\n  }\n  providers: T\n}\n\nexport interface SessionResult {\n  user?: User\n  expires: Date\n}\n\nexport type Options = typeof authOptions\n",
      "type": "registry:file",
      "target": "server/auth/types.ts"
    }
  ]
}