{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "auth-with-mongoose",
  "type": "registry:file",
  "files": [
    {
      "path": "registry/auth/core/queries.mongoose.ts.hbs",
      "content": "'use server'\n\nimport { sha256 } from '@oslojs/crypto/sha2'\nimport {\n  encodeBase32LowerCaseNoPadding,\n  encodeHexLowerCase,\n} from '@oslojs/encoding'\n\nimport type { SessionResult } from '@/server/auth/types'\nimport { authOptions } from '@/server/auth/config'\nimport { Password } from '@/server/auth/core/password'\nimport { db } from '@/server/db'\nimport { User } from '@/server/db/schema'\n\nasync function createSession(\n  userId: string,\n): Promise<{ sessionToken: string; expires: Date }> {\n  const bytes = new Uint8Array(20)\n  crypto.getRandomValues(bytes)\n  const sessionToken = encodeBase32LowerCaseNoPadding(bytes)\n\n  const token = hashSHA256(sessionToken)\n  const expires = new Date(Date.now() + authOptions.session.expires)\n\n  // Store the hashed token in the database\n  const session = await db.session.create({ token, expires, userId })\n  if (!session) throw new Error('Failed to create session')\n\n  // Return the unhashed token to the client along with expiration\n  return { sessionToken, expires: session.expires }\n}\n\nasync function validateToken(token: string): Promise<SessionResult> {\n  const sessionToken = hashSHA256(token)\n\n  // Lookup the session and associated user in the database\n  const session = await db.session.findOne({ token: sessionToken })\n  const user = await db.user.findOne({ _id: session?.userId })\n\n  // Return early if session not found\n  if (!session || !user) return { expires: new Date() }\n\n  const now = Date.now()\n\n  // Check if session has expired\n  if (now > session.expires.getTime()) {\n    await db.session.findOneAndDelete({ token: sessionToken })\n    return { expires: new Date() }\n  }\n\n  // Refresh session if it's beyond the refresh threshold\n  if (now >= session.expires.getTime() - authOptions.session.expiresThreshold) {\n    const newExpires = new Date(Date.now() + authOptions.session.expires)\n    await db.session.findOneAndUpdate(\n      { token: sessionToken },\n      { $set: { expires: newExpires } },\n      { new: true },\n    )\n    session.expires = newExpires\n  }\n\n  return { user, expires: session.expires }\n}\n\nasync function invalidateToken(token: string): Promise<void> {\n  await db.session.findOneAndDelete({ token: hashSHA256(token) })\n}\n\nasync function invalidateAllTokens(userId: string): Promise<void> {\n  await db.session.deleteMany({ userId })\n}\n\nasync function verifyCredentials(input: {\n  email: string\n  password: string\n}): Promise<{ sessionToken: string; expires: Date }> {\n  const user = await db.user.findOne({ email: input.email })\n  const account = await db.account.findOne({\n    provider: 'credentials',\n    accountId: user?._id,\n  })\n\n  if (\n    !user ||\n    !account?.password ||\n    !(await new Password().verify(account.password, input.password))\n  )\n    throw new Error('Invalid email or password')\n\n  return createSession(user.id)\n}\n\nasync function getOrCreateUserFromOAuth(data: {\n  provider: string\n  accountId: string\n  name: string\n  email: string\n  image: string\n}): Promise<User> {\n  const { provider, accountId, email } = data\n\n  const existingAccount = await db.account.findOne({ provider, accountId })\n  let existingUser = await db.user.findOne({ _id: existingAccount?.userId })\n  if (existingUser) return existingUser\n\n  existingUser = await db.user.findOne({ email })\n  if (existingUser) {\n    await db.account.create({\n      provider,\n      accountId,\n      userId: existingUser._id,\n    })\n    return existingUser\n  }\n\n  const newUser = await db.user.create(data)\n  if (!newUser) throw new Error('Failed to create user')\n\n  await db.account.create({ provider, accountId, userId: newUser._id })\n  return newUser\n}\n\nfunction hashSHA256(str: string): string {\n  return encodeHexLowerCase(sha256(new TextEncoder().encode(str)))\n}\n\nexport {\n  // Authentication\n  verifyCredentials,\n  getOrCreateUserFromOAuth,\n  // Session management\n  createSession,\n  validateToken,\n  invalidateToken,\n  invalidateAllTokens,\n}\n",
      "type": "registry:file",
      "target": "server/auth/core/queries.ts"
    },
    {
      "path": "registry/auth/types.mongoose.ts.hbs",
      "content": "import type { authOptions } from '@/server/auth/config'\nimport type { BaseProvider } from '@/server/auth/providers/base'\nimport type { User } from '@/server/db/schema'\n\nexport type Providers = Record<string, BaseProvider>\n\nexport interface AuthOptions<T extends Providers = Providers> {\n  cookieKey: string\n  cookieOptions: {\n    expires?: Date | number\n    maxAge?: number\n    domain?: string\n    path: string\n    secure: boolean\n    httpOnly: boolean\n    sameSite: 'strict' | 'lax' | 'none'\n    priority?: 'low' | 'medium' | 'high'\n    [key: string]: unknown\n  }\n  session: {\n    expires: number\n    expiresThreshold: number\n  }\n  providers: T\n}\n\nexport interface SessionResult {\n  user?: User\n  expires: Date\n}\n\nexport type Options = typeof authOptions\n",
      "type": "registry:file",
      "target": "server/auth/types.ts"
    }
  ]
}