{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "auth-with-prisma",
  "type": "registry:file",
  "files": [
    {
      "path": "registry/auth/core/queries.prisma.ts.hbs",
      "content": "'use server'\n\nimport { sha256 } from '@oslojs/crypto/sha2'\nimport {\n  encodeBase32LowerCaseNoPadding,\n  encodeHexLowerCase,\n} from '@oslojs/encoding'\n\nimport type { User } from '@/generated/prisma'\nimport type { SessionResult } from '@/server/auth/types'\nimport { authOptions } from '@/server/auth/config'\nimport { Password } from '@/server/auth/core/password'\nimport { db } from '@/server/db'\n\nasync function createSession(\n  userId: string,\n): Promise<{ sessionToken: string; expires: Date }> {\n  const bytes = new Uint8Array(20)\n  crypto.getRandomValues(bytes)\n  const sessionToken = encodeBase32LowerCaseNoPadding(bytes)\n\n  const token = hashSHA256(sessionToken)\n  const expires = new Date(Date.now() + authOptions.session.expires)\n\n  // Store the hashed token in the database\n  const session = await db.session.create({ data: { token, expires, userId } })\n  if (!session) throw new Error('Failed to create session')\n\n  // Return the unhashed token to the client along with expiration\n  return { sessionToken, expires: session.expires }\n}\n\nasync function validateToken(token: string): Promise<SessionResult> {\n  const sessionToken = hashSHA256(token)\n\n  // Lookup the session and associated user in the database\n  const result = await db.session.findUnique({\n    where: { token: sessionToken },\n    include: { user: true },\n  })\n\n  // Return early if session not found\n  if (!result) return { expires: new Date() }\n\n  const { user, ...session } = result\n  const now = Date.now()\n\n  // Check if session has expired\n  if (now > session.expires.getTime()) {\n    await db.session.delete({ where: { token: sessionToken } })\n    return { expires: new Date() }\n  }\n\n  // Refresh session if it's beyond the refresh threshold\n  if (now >= session.expires.getTime() - authOptions.session.expiresThreshold) {\n    const newExpires = new Date(Date.now() + authOptions.session.expires)\n    await db.session.update({\n      where: { token: sessionToken },\n      data: { expires: newExpires },\n    })\n    session.expires = newExpires\n  }\n\n  return { user, expires: session.expires }\n}\n\nasync function invalidateToken(token: string): Promise<void> {\n  await db.session.delete({ where: { token: hashSHA256(token) } })\n}\n\nasync function invalidateAllTokens(userId: string): Promise<void> {\n  await db.session.deleteMany({ where: { userId } })\n}\n\nasync function verifyCredentials(input: {\n  email: string\n  password: string\n}): Promise<{ sessionToken: string; expires: Date }> {\n  const user = await db.user.findUnique({\n    where: { email: input.email },\n    include: { accounts: { where: { provider: 'credentials' } } },\n  })\n\n  if (\n    !user ||\n    !user.accounts[0]?.password ||\n    !(await new Password().verify(user.accounts[0].password, input.password))\n  )\n    throw new Error('Invalid email or password')\n\n  return createSession(user.id)\n}\n\nasync function getOrCreateUserFromOAuth(data: {\n  provider: string\n  accountId: string\n  name: string\n  email: string\n  image: string\n}): Promise<User> {\n  const { provider, accountId, email } = data\n\n  const existingAccount = await db.account.findUnique({\n    where: { provider_accountId: { provider, accountId } },\n    include: { user: true },\n  })\n  if (existingAccount?.user) return existingAccount.user\n\n  return await db.$transaction(async (tx) => {\n    const existingUser = await tx.user.findUnique({ where: { email } })\n\n    if (existingUser) {\n      await tx.account.create({\n        data: { provider, accountId, userId: existingUser.id },\n      })\n      return existingUser\n    }\n\n    const newUser = await tx.user.create({ data })\n    if (!newUser) throw new Error('Failed to create user')\n\n    await tx.account.create({\n      data: { provider, accountId, userId: newUser.id },\n    })\n\n    return newUser\n  })\n}\n\nfunction hashSHA256(str: string): string {\n  return encodeHexLowerCase(sha256(new TextEncoder().encode(str)))\n}\n\nexport {\n  // Authentication\n  verifyCredentials,\n  getOrCreateUserFromOAuth,\n  // Session management\n  createSession,\n  validateToken,\n  invalidateToken,\n  invalidateAllTokens,\n}\n",
      "type": "registry:file",
      "target": "server/auth/core/queries.ts"
    },
    {
      "path": "registry/auth/types.prisma.ts.hbs",
      "content": "import type { User } from '@/generated/prisma'\nimport type { authOptions } from '@/server/auth/config'\nimport type { BaseProvider } from '@/server/auth/providers/base'\n\nexport type Providers = Record<string, BaseProvider>\n\nexport interface AuthOptions<T extends Providers = Providers> {\n  cookieKey: string\n  cookieOptions: {\n    expires?: Date | number\n    maxAge?: number\n    domain?: string\n    path: string\n    secure: boolean\n    httpOnly: boolean\n    sameSite: 'strict' | 'lax' | 'none'\n    priority?: 'low' | 'medium' | 'high'\n    [key: string]: unknown\n  }\n  session: {\n    expires: number\n    expiresThreshold: number\n  }\n  providers: T\n}\n\nexport interface SessionResult {\n  user?: User\n  expires: Date\n}\n\nexport type Options = typeof authOptions\n",
      "type": "registry:file",
      "target": "server/auth/types.ts"
    }
  ]
}