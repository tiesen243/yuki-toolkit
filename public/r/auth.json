{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "auth",
  "type": "registry:file",
  "title": "Yuki Auth",
  "description": "A simple authentication system from scratch.",
  "dependencies": [
    "@oslojs/crypto",
    "@oslojs/encoding",
    "arctic"
  ],
  "files": [
    {
      "path": "registry/auth/core/password/scrypt.ts.hbs",
      "content": "// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\n/* \nThe MIT License (MIT)\n\nCopyright (c) 2022 Paul Miller (https://paulmillr.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. \n*/\n\nexport async function scrypt(\n  password: Uint8Array,\n  salt: Uint8Array,\n  options: {\n    N: number\n    r: number\n    p: number\n    dkLen?: number\n    maxmem?: number\n  },\n): Promise<Uint8Array> {\n  const { N, r, p } = options\n  const dkLen = options.dkLen ?? 32\n  const maxmem = 1024 ** 3 + 1024\n  const blockSize = 128 * r\n  const blockSize32 = blockSize / 4\n  if (\n    N <= 1 ||\n    (N & (N - 1)) !== 0 ||\n    N >= 2 ** (blockSize / 8) ||\n    N > 2 ** 32\n  ) {\n    throw new Error(\n      'Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32',\n    )\n  }\n  if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\n    throw new Error(\n      'Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)',\n    )\n  }\n  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n    throw new Error(\n      'Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32',\n    )\n  }\n  const memUsed = blockSize * (N + p)\n  if (memUsed > maxmem) {\n    throw new Error(\n      `Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`,\n    )\n  }\n  const B = await pbkdf2(password, salt, { c: 1, dkLen: blockSize * p })\n  const B32 = u32(B)\n  const V = u32(new Uint8Array(blockSize * N))\n  const tmp = u32(new Uint8Array(blockSize))\n  for (let pi = 0; pi < p; pi++) {\n    const Pi = blockSize32 * pi\n    for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i] // V[0] = B[i]\n    for (let i = 0, pos = 0; i < N - 1; i++) {\n      BlockMix(V, pos, V, (pos += blockSize32), r) // V[i] = BlockMix(V[i-1]);\n      await new Promise<void>((r) => {\n        r()\n      }) // await next tick\n    }\n    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r) // Process last element\n    for (let i = 0; i < N; i++) {\n      // First u32 of the last 64-byte block (u32 is LE)\n      const j = B32[Pi + blockSize32 - 16] % N // j = Integrify(X) % iterations\n      for (let k = 0; k < blockSize32; k++) {\n        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k] // tmp = B ^ V[j]\n      }\n\n      BlockMix(tmp, 0, B32, Pi, r) // B = BlockMix(B ^ V[j])\n      await new Promise<void>((r) => {\n        r()\n      }) // await next tick\n    }\n  }\n  const res = await pbkdf2(password, B, { c: 1, dkLen })\n  B.fill(0)\n  V.fill(0)\n  tmp.fill(0)\n  return res\n}\n\nfunction rotl(a: number, b: number): number {\n  return (a << b) | (a >>> (32 - b))\n}\n\nfunction XorAndSalsa(\n  prev: Uint32Array,\n  pi: number,\n  input: Uint32Array,\n  ii: number,\n  out: Uint32Array,\n  oi: number,\n): void {\n  const y00 = prev[pi++] ^ input[ii++],\n    y01 = prev[pi++] ^ input[ii++]\n  const y02 = prev[pi++] ^ input[ii++],\n    y03 = prev[pi++] ^ input[ii++]\n  const y04 = prev[pi++] ^ input[ii++],\n    y05 = prev[pi++] ^ input[ii++]\n  const y06 = prev[pi++] ^ input[ii++],\n    y07 = prev[pi++] ^ input[ii++]\n  const y08 = prev[pi++] ^ input[ii++],\n    y09 = prev[pi++] ^ input[ii++]\n  const y10 = prev[pi++] ^ input[ii++],\n    y11 = prev[pi++] ^ input[ii++]\n  const y12 = prev[pi++] ^ input[ii++],\n    y13 = prev[pi++] ^ input[ii++]\n  const y14 = prev[pi++] ^ input[ii++],\n    y15 = prev[pi++] ^ input[ii++]\n  let x00 = y00,\n    x01 = y01,\n    x02 = y02,\n    x03 = y03,\n    x04 = y04,\n    x05 = y05,\n    x06 = y06,\n    x07 = y07,\n    x08 = y08,\n    x09 = y09,\n    x10 = y10,\n    x11 = y11,\n    x12 = y12,\n    x13 = y13,\n    x14 = y14,\n    x15 = y15\n  for (let i = 0; i < 8; i += 2) {\n    x04 ^= rotl((x00 + x12) | 0, 7)\n    x08 ^= rotl((x04 + x00) | 0, 9)\n    x12 ^= rotl((x08 + x04) | 0, 13)\n    x00 ^= rotl((x12 + x08) | 0, 18)\n    x09 ^= rotl((x05 + x01) | 0, 7)\n    x13 ^= rotl((x09 + x05) | 0, 9)\n    x01 ^= rotl((x13 + x09) | 0, 13)\n    x05 ^= rotl((x01 + x13) | 0, 18)\n    x14 ^= rotl((x10 + x06) | 0, 7)\n    x02 ^= rotl((x14 + x10) | 0, 9)\n    x06 ^= rotl((x02 + x14) | 0, 13)\n    x10 ^= rotl((x06 + x02) | 0, 18)\n    x03 ^= rotl((x15 + x11) | 0, 7)\n    x07 ^= rotl((x03 + x15) | 0, 9)\n    x11 ^= rotl((x07 + x03) | 0, 13)\n    x15 ^= rotl((x11 + x07) | 0, 18)\n    x01 ^= rotl((x00 + x03) | 0, 7)\n    x02 ^= rotl((x01 + x00) | 0, 9)\n    x03 ^= rotl((x02 + x01) | 0, 13)\n    x00 ^= rotl((x03 + x02) | 0, 18)\n    x06 ^= rotl((x05 + x04) | 0, 7)\n    x07 ^= rotl((x06 + x05) | 0, 9)\n    x04 ^= rotl((x07 + x06) | 0, 13)\n    x05 ^= rotl((x04 + x07) | 0, 18)\n    x11 ^= rotl((x10 + x09) | 0, 7)\n    x08 ^= rotl((x11 + x10) | 0, 9)\n    x09 ^= rotl((x08 + x11) | 0, 13)\n    x10 ^= rotl((x09 + x08) | 0, 18)\n    x12 ^= rotl((x15 + x14) | 0, 7)\n    x13 ^= rotl((x12 + x15) | 0, 9)\n    x14 ^= rotl((x13 + x12) | 0, 13)\n    x15 ^= rotl((x14 + x13) | 0, 18)\n  }\n  out[oi++] = (y00 + x00) | 0\n  out[oi++] = (y01 + x01) | 0\n  out[oi++] = (y02 + x02) | 0\n  out[oi++] = (y03 + x03) | 0\n  out[oi++] = (y04 + x04) | 0\n  out[oi++] = (y05 + x05) | 0\n  out[oi++] = (y06 + x06) | 0\n  out[oi++] = (y07 + x07) | 0\n  out[oi++] = (y08 + x08) | 0\n  out[oi++] = (y09 + x09) | 0\n  out[oi++] = (y10 + x10) | 0\n  out[oi++] = (y11 + x11) | 0\n  out[oi++] = (y12 + x12) | 0\n  out[oi++] = (y13 + x13) | 0\n  out[oi++] = (y14 + x14) | 0\n  out[oi++] = (y15 + x15) | 0\n}\n\nasync function pbkdf2(\n  password: Uint8Array,\n  salt: Uint8Array,\n  options: {\n    c: number\n    dkLen: number\n  },\n): Promise<Uint8Array> {\n  const pwKey = await crypto.subtle.importKey(\n    'raw',\n    password,\n    'PBKDF2',\n    false,\n    ['deriveBits'],\n  )\n  const keyBuffer = await crypto.subtle.deriveBits(\n    {\n      name: 'PBKDF2',\n      hash: 'SHA-256',\n      salt,\n      iterations: options.c,\n    },\n    pwKey,\n    options.dkLen * 8,\n  )\n  return new Uint8Array(keyBuffer)\n}\n\nfunction BlockMix(\n  input: Uint32Array,\n  ii: number,\n  out: Uint32Array,\n  oi: number,\n  r: number,\n): void {\n  let head = oi + 0\n  let tail = oi + 16 * r\n  for (let i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]\n  for (let i = 0; i < r; i++, head += 16, ii += 16) {\n    XorAndSalsa(out, tail, input, ii, out, head)\n    if (i > 0) tail += 16\n    XorAndSalsa(out, head, input, (ii += 16), out, tail)\n  }\n}\n\nfunction u32(arr: Uint8Array): Uint32Array {\n  return new Uint32Array(\n    arr.buffer,\n    arr.byteOffset,\n    Math.floor(arr.byteLength / 4),\n  )\n}\n",
      "type": "registry:file",
      "target": "server/auth/core/password/scrypt.ts"
    },
    {
      "path": "registry/auth/core/password/index.ts.hbs",
      "content": "import { constantTimeEqual } from '@oslojs/crypto/subtle'\nimport { decodeHex, encodeHexLowerCase } from '@oslojs/encoding'\n\nimport { scrypt } from '@/server/auth/core/password/scrypt'\n\nexport class Password {\n  private N: number\n  private r: number\n  private p: number\n  private dkLen: number\n\n  constructor(options?: {\n    N?: number\n    r?: number\n    p?: number\n    dkLen?: number\n  }) {\n    this.N = options?.N ?? 16384\n    this.r = options?.r ?? 16\n    this.p = options?.p ?? 1\n    this.dkLen = options?.dkLen ?? 64\n  }\n\n  async hash(password: string): Promise<string> {\n    const salt = encodeHexLowerCase(crypto.getRandomValues(new Uint8Array(16)))\n    const key = await this.generateKey(password.normalize('NFKC'), salt)\n    return `${salt}:${encodeHexLowerCase(key)}`\n  }\n\n  async verify(hash: string, password: string): Promise<boolean> {\n    const parts = hash.split(':')\n    if (parts.length !== 2) return false\n\n    const [salt, key] = parts\n    const targetKey = await this.generateKey(password.normalize('NFKC'), salt)\n    return constantTimeEqual(targetKey, decodeHex(key ?? ''))\n  }\n\n  private async generateKey(data: string, salt?: string): Promise<Uint8Array> {\n    const textEncoder = new TextEncoder()\n    const keyUint8Array = await scrypt(\n      textEncoder.encode(data),\n      textEncoder.encode(salt),\n      { N: this.N, r: this.r, p: this.p, dkLen: this.dkLen },\n    )\n\n    return new Uint8Array(keyUint8Array)\n  }\n}\n",
      "type": "registry:file",
      "target": "server/auth/core/password/index.ts"
    },
    {
      "path": "registry/auth/core/cookies.ts.hbs",
      "content": "/**\n * Cookie management utilities for authentication\n *\n * Implements secure cookie handling for authentication sessions following\n * best practices as recommended by Lucia Auth.\n *\n * @see https://lucia-auth.com/sessions/cookies\n */\nimport { cookies } from 'next/headers'\n\nimport type { AuthOptions } from '@/server/auth/types'\n\nasync function getCookie(\n  key: string,\n  request?: Request,\n): Promise<string | undefined> {\n  if (request) {\n    const cookies = request.headers\n      .get('cookie')\n      ?.split(';')\n      .reduce((acc: Record<string, string>, cookie) => {\n        const [key, value] = cookie.trim().split('=')\n        if (key && value) acc[key] = decodeURIComponent(value)\n        return acc\n      }, {})\n    return cookies?.[key]\n  }\n  return (await cookies()).get(key)?.value\n}\n\nasync function setCookie(\n  key: string,\n  value: string,\n  options: Partial<AuthOptions['cookieOptions']> = {},\n  response?: Response,\n): Promise<void> {\n  delete options.key\n\n  if (response) {\n    // Format Date objects to UTC string if present\n    if (options.expires instanceof Date)\n      options.expires = options.expires.toUTCString() as never\n\n    const cookieString = `${key}=${value}; ${Object.entries(options)\n      .map(([k, v]) => `${k}=${v}`)\n      .join('; ')}`\n\n    response.headers.append('set-cookie', cookieString)\n  } else (await cookies()).set(key, value, options)\n}\n\nasync function deleteCookie(key: string, response?: Response): Promise<void> {\n  if (response)\n    response.headers.append(\n      'set-cookie',\n      `${key}=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0`,\n    )\n  else (await cookies()).delete(key)\n}\n\nexport { getCookie, setCookie, deleteCookie }\n",
      "type": "registry:file",
      "target": "server/auth/core/cookies.ts"
    },
    {
      "path": "registry/auth/core/index.ts.hbs",
      "content": "import { generateCodeVerifier, generateState, OAuth2RequestError } from 'arctic'\n\nimport type { AuthOptions, Providers, SessionResult } from '@/server/auth/types'\nimport { deleteCookie, getCookie, setCookie } from '@/server/auth/core/cookies'\nimport {\n  createSession,\n  getOrCreateUserFromOAuth,\n  invalidateToken,\n  validateToken,\n  verifyCredentials,\n} from '@/server/auth/core/queries'\n\nexport function Auth<TProviders extends Providers>({\n  cookieKey,\n  cookieOptions,\n  providers,\n}: AuthOptions<TProviders>) {\n  async function auth(request?: Request): Promise<SessionResult> {\n    const token =\n      (await getCookie(cookieKey, request)) ??\n      request?.headers.get('Authorization')?.replace('Bearer ', '') ??\n      ''\n    return validateToken(token)\n  }\n\n  async function signOut(request?: Request): Promise<void> {\n    const token =\n      (await getCookie(cookieKey, request)) ??\n      request?.headers.get('Authorization')?.replace('Bearer ', '') ??\n      ''\n\n    if (token) {\n      await invalidateToken(token)\n      if (!request) await deleteCookie(cookieKey)\n    }\n  }\n\n  const createRedirectResponse = (url: string | URL): Response =>\n    new Response(null, {\n      status: 302,\n      headers: { location: url.toString() },\n    })\n\n  const handleOAuthStart = async (req: Request): Promise<Response> => {\n    const url = new URL(req.url)\n    const redirectTo = url.searchParams.get('redirect_to') ?? '/'\n    const providerName = String(url.pathname.split('/').pop())\n    const provider = providers[providerName]\n    if (!provider) throw new Error(`Provider ${providerName} is not supported`)\n\n    // Handle mobile development redirects\n    if (\n      redirectTo.startsWith('exp://') &&\n      process.env.NODE_ENV === 'development'\n    ) {\n      if (!process.env.AUTH_PROXY_URL)\n        throw new Error('AUTH_PROXY_URL is not set')\n\n      const redirectUrl = new URL(\n        `https://${process.env.AUTH_PROXY_URL}${url.pathname}`,\n      )\n      redirectUrl.searchParams.set('redirect_to', redirectTo)\n      return createRedirectResponse(redirectUrl)\n    }\n\n    // Generate OAuth parameters and create authorization URL\n    const state = generateState()\n    const codeVerifier = generateCodeVerifier()\n    const authorizationUrl = provider.createAuthorizationURL(\n      state,\n      codeVerifier,\n    )\n\n    // Set cookies for the callback and create response\n    const response = createRedirectResponse(authorizationUrl)\n    await Promise.all([\n      setCookie('auth_state', state, cookieOptions, response),\n      setCookie('code_verifier', codeVerifier, cookieOptions, response),\n      setCookie('redirect_to', redirectTo, cookieOptions, response),\n    ])\n\n    return response\n  }\n\n  const handleOAuthCallback = async (request: Request): Promise<Response> => {\n    const url = new URL(request.url)\n    const providerName = String(url.pathname.split('/').slice(-2, -1))\n    const provider = providers[providerName]\n    if (!provider) throw new Error(`Provider ${providerName} is not supported`)\n\n    // Get parameters from URL and cookies\n    const code = url.searchParams.get('code')\n    const state = url.searchParams.get('state')\n    const [storedState, storedCode, redirectTo] = await Promise.all([\n      getCookie('auth_state', request),\n      getCookie('code_verifier', request),\n      getCookie('redirect_to', request),\n    ])\n\n    if (!code || !state || !storedState || !storedCode)\n      throw new Error('Missing required parameters')\n\n    // Fetch user data and create session\n    const userData = await provider.fetchUserData(code, storedCode)\n    const user = await getOrCreateUserFromOAuth({\n      ...userData,\n      provider: providerName,\n    })\n    const sessionCookie = await createSession(user.id)\n\n    // Create response and handle cross-origin redirects\n    const redirectUrl = new URL(redirectTo ?? '/', request.url)\n    if (redirectUrl.origin !== url.origin)\n      redirectUrl.searchParams.set('token', sessionCookie.sessionToken)\n\n    const response = createRedirectResponse(redirectUrl)\n\n    // Set session cookie and clear temporary cookies\n    await Promise.all([\n      setCookie(\n        cookieKey,\n        sessionCookie.sessionToken,\n        { ...cookieOptions, expires: sessionCookie.expires },\n        response,\n      ),\n      deleteCookie('auth_state', response),\n      deleteCookie('code_verifier', response),\n      deleteCookie('redirect_to', response),\n    ])\n\n    return response\n  }\n\n  const handleGetRequest = async (request: Request): Promise<Response> => {\n    const url = new URL(request.url)\n    const pathName = url.pathname\n\n    try {\n      // User session verification endpoint\n      if (pathName === '/api/auth') {\n        const session = await auth(request)\n        return Response.json(session)\n      }\n\n      // OAuth flow endpoints\n      return url.pathname.endsWith('/callback')\n        ? await handleOAuthCallback(request)\n        : await handleOAuthStart(request)\n    } catch (error) {\n      const errorMessage =\n        error instanceof OAuth2RequestError\n          ? { error: error.message, description: error.description }\n          : error instanceof Error\n            ? { error: error.message }\n            : { error: 'Internal Server Error' }\n      const status = error instanceof OAuth2RequestError ? 400 : 500\n      return Response.json(errorMessage, { status })\n    }\n  }\n\n  const handlePostRequest = async (request: Request): Promise<Response> => {\n    const { pathname } = new URL(request.url)\n\n    try {\n      // Sign-in endpoint\n      if (pathname === '/api/auth/sign-in') {\n        const { email, password } = (await request.json()) as {\n          email: string\n          password: string\n        }\n        const { sessionToken, expires } = await verifyCredentials({\n          email,\n          password,\n        })\n\n        const response = Response.json({ token: sessionToken }, { status: 200 })\n        await setCookie(\n          cookieKey,\n          sessionToken,\n          { ...cookieOptions, expires },\n          response,\n        )\n        return response\n      }\n\n      // Sign-out endpoint\n      if (pathname === '/api/auth/sign-out') {\n        await signOut(request)\n        const response = createRedirectResponse('/')\n        await deleteCookie(cookieKey, response)\n        return response\n      }\n\n      return new Response('Not Found', { status: 404 })\n    } catch (error) {\n      if (error instanceof Error)\n        return Response.json({ error: error.message }, { status: 401 })\n      return Response.json({ error: 'Internal Server Error' }, { status: 500 })\n    }\n  }\n\n  const withCors = (handler: (request: Request) => Promise<Response>) => {\n    return async (request: Request) => {\n      const response = await handler(request)\n      response.headers.set('Access-Control-Allow-Origin', '*')\n      response.headers.set('Access-Control-Request-Method', '*')\n      response.headers.set('Access-Control-Allow-Methods', 'OPTIONS, GET, POST')\n      response.headers.set('Access-Control-Allow-Headers', '*')\n      return response\n    }\n  }\n\n  return {\n    auth,\n    signIn: verifyCredentials,\n    signOut,\n    handlers: {\n      GET: withCors(handleGetRequest),\n      POST: withCors(handlePostRequest),\n    },\n  }\n}\n",
      "type": "registry:file",
      "target": "server/auth/core/index.ts"
    },
    {
      "path": "registry/auth/providers/base.ts.hbs",
      "content": "export interface ProviderUserData {\n  accountId: string\n  email: string\n  name: string\n  image: string\n}\n\nexport abstract class BaseProvider {\n  protected abstract provider: unknown\n\n  protected abstract readonly API_URL: string\n  protected abstract readonly SCOPES: string[]\n\n  abstract createAuthorizationURL(\n    state: string,\n    codeVerifier: string | null,\n  ): URL\n\n  abstract fetchUserData(\n    code: string,\n    codeVerifier: string | null,\n  ): Promise<ProviderUserData>\n\n  protected createCallbackUrl(provider: string) {\n    let baseUrl = `http://localhost:${process.env.PORT ?? 3000}`\n    if (typeof window !== 'undefined') baseUrl = window.location.origin\n    if (process.env.VERCEL_PROJECT_PRODUCTION_URL)\n      baseUrl = `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`\n    if (process.env.VERCEL_URL) baseUrl = `https://${process.env.VERCEL_URL}`\n\n    return `${baseUrl}/api/auth/${provider}/callback`\n  }\n}\n",
      "type": "registry:file",
      "target": "server/auth/providers/base.ts"
    },
    {
      "path": "registry/auth/config.ts.hbs",
      "content": "import type { AuthOptions } from '@/server/auth/types'\n\n/**\n * Authentication configuration\n *\n * @remarks\n * Each provider requires CLIENT_ID and CLIENT_SECRET environment variables\n * (e.g., DISCORD_CLIENT_ID, DISCORD_CLIENT_SECRET)\n *\n * Callback URL should be set to: {{ BASE_URL }}/api/auth/{{ provider }}/callback\n * (e.g., https://yourdomain.com/api/auth/discord/callback)\n */\nexport const authOptions = {\n  cookieKey: 'auth_token',\n  cookieOptions: {\n    path: '/',\n    httpOnly: true,\n    sameSite: 'lax',\n    secure: process.env.NODE_ENV === 'production',\n  },\n  session: {\n    expires: 1000 * 60 * 60 * 24 * 30, // 30 days in milliseconds\n    expiresThreshold: 1000 * 60 * 60 * 24 * 15, // 15 days in milliseconds\n  },\n  providers: {},\n} satisfies AuthOptions\n",
      "type": "registry:file",
      "target": "server/auth/config.ts"
    },
    {
      "path": "registry/auth/index.ts.hbs",
      "content": "import { cache } from 'react'\n\nimport { authOptions } from '@/server/auth/config'\nimport { Auth } from '@/server/auth/core'\n\nconst { auth: uncachedAuth, signIn, signOut, handlers } = Auth(authOptions)\n\nconst auth = cache(uncachedAuth)\n\nexport { auth, signIn, signOut, handlers }\n",
      "type": "registry:file",
      "target": "server/auth/index.ts"
    },
    {
      "path": "registry/auth/route.ts.hbs",
      "content": "import { handlers } from '@/server/auth'\n\nexport const { GET, POST } = handlers\n",
      "type": "registry:page",
      "target": "app/api/auth/[[...auth]]/route.ts"
    },
    {
      "path": "registry/auth/use-session.tsx.hbs",
      "content": "'use client'\n\nimport * as React from 'react'\n\nimport type { Options, SessionResult } from '@/server/auth/types'\n\ntype Provider = 'credentials' | keyof Options['providers']\n\ntype SessionContextValue = {\n  signIn: <TProvider extends Provider>(\n    provider: TProvider,\n    ...args: TProvider extends 'credentials'\n      ? [options: { email: string; password: string }]\n      : [options?: { redirectTo: string }]\n  ) => Promise<TProvider extends 'credentials' ? string : undefined>\n  signOut: () => Promise<void>\n  refresh: (token?: string) => Promise<void>\n} & (\n  | { status: 'loading'; session: SessionResult }\n  | {\n      status: 'authenticated'\n      session: { user: NonNullable<SessionResult['user']>; expires: Date }\n    }\n  | { status: 'unauthenticated'; session: { expires: Date } }\n)\n\nconst SessionContext = React.createContext<SessionContextValue | undefined>(\n  undefined,\n)\n\nfunction useSession(): SessionContextValue {\n  const ctx = React.use(SessionContext)\n  if (!ctx) throw new Error('useSession must be used within a SessionProvider')\n  return ctx\n}\n\nfunction SessionProvider({\n  children,\n  session: initialSession,\n}: Readonly<{ children: React.ReactNode; session?: SessionResult }>) {\n  const hasInitialSession = initialSession !== undefined\n  const [isLoading, setIsLoading] = React.useState(!hasInitialSession)\n  const [session, setSession] = React.useState<SessionResult>(() => {\n    if (hasInitialSession) return initialSession\n    return { expires: new Date() }\n  })\n\n  const status = React.useMemo(() => {\n    if (isLoading) return 'loading' as const\n    return session.user\n      ? ('authenticated' as const)\n      : ('unauthenticated' as const)\n  }, [session, isLoading])\n\n  const fetchSession = React.useCallback(\n    async (token?: string): Promise<void> => {\n      setIsLoading(true)\n      try {\n        const res = await fetch('/api/auth', {\n          headers: token ? { Authorization: `Bearer ${token}` } : {},\n        })\n        if (!res.ok) throw new Error(`Failed to fetch session: ${res.status}`)\n\n        const sessionData = (await res.json()) as SessionResult\n        setSession(sessionData)\n      } catch (error) {\n        console.error('Error fetching session:', error)\n        setSession({ expires: new Date() })\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [],\n  )\n\n  const signIn = React.useCallback(\n    async <TProvider extends Provider>(\n      provider: TProvider,\n      ...args: TProvider extends 'credentials'\n        ? [options: { email: string; password: string }]\n        : [options?: { redirectTo: string }]\n    ): Promise<TProvider extends 'credentials' ? string : undefined> => {\n      if (provider === 'credentials') {\n        try {\n          const res = await fetch('/api/auth/sign-in', {\n            method: 'POST',\n            body: JSON.stringify(args[0]),\n          })\n\n          const json = (await res.json()) as { token: string; error: string }\n\n          if (!res.ok) throw new Error(json.error || 'Authentication failed')\n\n          await fetchSession(json.token)\n          return json.token as TProvider extends 'credentials'\n            ? string\n            : undefined\n        } catch (error) {\n          console.error('Sign in error:', error)\n          throw error\n        }\n      } else {\n        const redirectTo =\n          (args[0] as { redirectTo?: string } | undefined)?.redirectTo ?? '/'\n        window.location.href = `/api/auth/${provider}?redirect_to=${encodeURIComponent(redirectTo)}`\n        return undefined as TProvider extends 'credentials' ? string : undefined\n      }\n    },\n    [fetchSession],\n  )\n\n  const signOut = React.useCallback(async (): Promise<void> => {\n    try {\n      const res = await fetch('/api/auth/sign-out', { method: 'POST' })\n      if (!res.ok) throw new Error(`Sign out failed: ${res.status}`)\n      setSession({ expires: new Date() })\n      window.location.reload()\n    } catch (error) {\n      console.error('Error signing out:', error)\n      throw error\n    }\n  }, [])\n\n  // Fetch initial session if not provided\n  React.useEffect(() => {\n    if (hasInitialSession) return\n    void fetchSession()\n  }, [fetchSession, hasInitialSession])\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const value = React.useMemo(\n    () =>\n      ({\n        session,\n        status,\n        signIn,\n        signOut,\n        refresh: fetchSession,\n      }) as SessionContextValue,\n    [session, status, signIn, signOut, fetchSession],\n  )\n\n  return <SessionContext value={value}>{children}</SessionContext>\n}\n\nexport { useSession, SessionProvider }\n",
      "type": "registry:hook",
      "target": "hooks/use-session.tsx"
    }
  ],
  "categories": [
    "authentication"
  ]
}